Sjogren syndrome microarray data analysis
========================================================
Topics to be covered:
* Data preparation, outliers identification and their effect on functional enrichment analyses
* Using ComBat to account for batch effect
* KEGG, Reactome, GO enrichment analyses
* Genes best correlated with clinical parameters, ant their functional significance
* TODO

```{r setup, echo=FALSE, include=FALSE, cache=FALSE}
# Set up the environment
library(knitr) 
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=F, tidy=T, fig.keep='high', echo=T, dpi=300, out.width=700)
options(replace.assign=TRUE, width=120)
set.seed(1)
HIDE=T # If true, mask any data labels
```

```{r loadLibraries, echo=FALSE, warning=FALSE, message=FALSE}
# Load necessary packages
suppressMessages(library(Biobase))
suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(reactome.db))
suppressMessages(library(KEGG.db))
suppressMessages(library(arrayQualityMetrics))
suppressMessages(library(limma))
suppressMessages(library(genefilter))
suppressMessages(library(sva))
suppressMessages(library(WGCNA))
suppressMessages(library(gplots))
suppressMessages(library(RColorBrewer))
suppressMessages(library(tspair))
suppressMessages(library(gridExtra))
suppressMessages(library(GO.db))
suppressMessages(library(GOstats))
suppressMessages(library(Hmisc))
# Preparing environment for remapping Gene Symbols to Entrez IDs
x <- org.Hs.egSYMBOL2EG
# Get the entrez gene identifiers that are mapped to a gene symbol
mapped_genes <- mappedkeys(x)
# Convert to a list
xx <- as.list(x[mapped_genes])
```

```{r clinCorrel, echo=FALSE}
# A wrapper function to visualize top 20 genes best correlated with a clinical parameter,
# and perform pathway/GO enrichment analysis on top 100 best correlated genes
clinCorrel <- function(m, fileName=NULL, combat_edata=combat_edata) {
  corrgenes <- apply(combat_edata, 1, function(x) rcorr(x, m))
  corrgenes <- cbind(sapply(corrgenes, function(x) x$r[1, 2]), 
               sapply(corrgenes, function(x) x$P[1, 2]))
  colnames(corrgenes) <- c("CorrCoeff", "Pval")
  corrgenes <- corrgenes[order(corrgenes[, "CorrCoeff"], decreasing=T), ]
  if (!is.null(fileName)) {
    write.table(corrgenes, paste("results//", fileName, sep=""), sep="\t", row.names=F)
  }
  grid.table(merge(corrgenes[1:20, ], annot.f, by="row.names"), gp=gpar(fontsize=6), core.just="left")
  return(corrgenes)
}

clinCorrelPathways <- function(genes, fileName=NULL) {
  res.pathway <- reactomeEnrichment(as.matrix(genes))
  message(paste("Number of significant pathways:", res.pathway[[2]]))
  if (res.pathway[[2]] > 0) {
    if (!is.null(fileName)) {
      write.table(result, paste("results//", fileName, sep=""), sep="\t", row.names=F)
    }
    if (res.pathway[[2]] > 20) {t <- 20} else {t <- res.pathway[[2]]}
    grid.table(res.pathway[[1]][1:t, ], gp=gpar(fontsize=6))
  }  
}

clinCorrelGOs <- function(genes, fileName=NULL) {
  res.GO <- Enrichment(as.matrix(genes) , "GO")
  message(paste("Number of significant ontologies:", res.GO[[2]]))
  if (res.GO[[2]] > 0) {
  if (!is.null(fileName)) {
    write.table(result, paste("results//", fileName, sep=""), sep="\t", row.names=F)
  }
  if (res.GO[[2]] > 20) {t <- 20} else {t <-res.GO[[2]]}
    grid.table(res.GO[[1]][1:t, ], gp=gpar(fontsize=6))
  }
}

```

```{r Enrichment, echo=FALSE}
# Perform GO enrichment analysis of topTable produced by limma.
# use use for KEGG of GO enrichment analyses
# Provide which ontology space to use, "MF", "BP", of "CC"
# Returns a list of the results, and total count of significant enrichments
Enrichment <- function(res, use="GO", fileName=NULL, ont="BP")
{
  res.genes <- as.character(unique(annot.f[rownames(res), "GeneName"]))
  # Convert selected and all gene names to Entrez IDs, removing NAs
  sel.entrez <- unlist(xx)[res.genes]; sel.entrez <- sel.entrez[!is.na(sel.entrez)]
  all.entrez <- unlist(xx)[unique(annot.f[, "GeneName"])]; all.entrez <- all.entrez[!is.na(all.entrez)]
  # Prepare parameters for the enrichment analysis
  if (use == "GO")
    {
    params <- new('GOHyperGParams', geneIds=sel.entrez, universeGeneIds=all.entrez, ontology=ont,
 pvalueCutoff=0.05, conditional=F, testDirection='over', annotation="org.Hs.eg.db")
    }
 else
   {
    params <- new('KEGGHyperGParams', geneIds=sel.entrez, universeGeneIds=all.entrez, pvalueCutoff=0.05, testDirection='over', annotation="org.Hs.eg.db") 
   }
  hgOver <- hyperGTest(params)
  result <- summary(hgOver)
  result <- cbind(result, p.adjust(result$Pvalue, method="BH")) # Append corrected for multiple testing p-value
  colnames(result)[length(colnames(result))] <- "p.adj"
  result <- result[result$p.adj < 0.1, ] # Subset the results keeping FDR at 10%
  if (!is.null(fileName)) {
    write.table(result, paste("results//", fileName, sep=""), sep="\t", row.names=F)
  }
  return(list(result, nrow(result)))
}
```

```{r reactomeEnrichment, echo=FALSE}
# Perform Reactome pathway enrichment analysis of topTable produced by limma
# Returns a list of the results, and total count of significant enrichments
reactomeEnrichment <- function(res, fileName=NULL)
{
  res.genes <- as.character(unique(annot.f[rownames(res), "GeneName"]))
  # Convert selected and all gene names to Entrez IDs, removing NAs
  sel.entrez <- unlist(xx)[res.genes]; sel.entrez <- sel.entrez[!is.na(sel.entrez)]
  all.entrez <- unlist(xx)[unique(annot.f[, "GeneName"])]; all.entrez <- all.entrez[!is.na(all.entrez)]
  # Prepare pathways and counts
  entrez2path <- as.list(reactomeEXTID2PATHID) # EntrezIDs to pathway IDs mapping
  sel.counts <- table(unlist(entrez2path[sel.entrez])) # Selected gene counts in pathways
  all.counts <- table(unlist(entrez2path[all.entrez])) # All gene counts
  n.sel <- length(sel.entrez) # Total number of selected genes
  n.all <- length(all.entrez) # Total number of all genes
  pathways <- names(sel.counts) # PAthways to test for enrichment
  pathway.names <- as.list(reactomePATHID2NAME) # Pathway ID to name mapping
  # For each pathway, construct 2x2 contingency table and calculate the enrichment p-value using Fisher's exact test
  result <- lapply(pathways, function(p) 
  {
                   sel <- sel.counts[[p]] 
                   all <- all.counts[[p]]
                   pathway.name <- pathway.names[[p]]
                   m <- matrix(c(sel, all, n.sel-sel, n.all-all),
                               byrow=T,nrow=2)
                   p.value <- fisher.test(m, alternative="greater")$p.value
                   data.frame(PathwayID=p, 
                              Pathway=pathway.name,
                              N.Selected=sel,
                              N.In.Category=all,
                              p.value=p.value)
  }
  ) # End lapply
  result <- as.data.frame(do.call(rbind, result)) # Convert list to data frame
  result <- result[order(result$p.value),] # Order by p-value
  result <- cbind(result, p.adjust(result$p.value, method="BH")) # Append corrected for multiple testing p-value
  colnames(result)[length(colnames(result))] <- "p.adj"
  # result <- result[result$p.adj < 0.1, ] # Subset the results keeping FDR at 10%
  if (!is.null(fileName)) {
    write.table(result, paste("results//", fileName, sep=""), sep="\t", row.names=F)
  }
  return(list(result, sum(result$p.adj < 0.05)))
}
```

```{r loadDataFunctions, echo=FALSE}
# Load meta- and expression data, specifying outlier IDs
loadMeta <- function(outliersRemove)
{ # Load meta data
  p <- patients
  if (outliersRemove) {p <- patients[!patients %in% c("p1033216.2", "p1033680.6...5.")]}
  meta <- as.data.frame(t(meta12[, p])) # Subsetting
  colnames(meta) <- sapply(colnames(meta), function(x) gsub(" ", "", x)) # Removing spaces from column names
  write.table(meta, "data//meta.txt", sep="\t", row.names=T) # Store loaded meta data
  return(meta)
}

loadExprs <- function(outliersRemove)
{ # Load expression data
  p <- patients
  if (outliersRemove) {p <- patients[!patients %in% c("p1033216.2", "p1033680.6...5.")]}
  exprs.n <- log2(normalizeQuantiles(exprs[, p]))
  colnames(exprs.n) <- colnames(exprs[, p])
  rownames(exprs.n) <- paste("gene", seq(1,nrow(exprs.n)), sep="") # Dummy row names, to be later used for merging
  return(exprs.n) # Subsetting
}

```

```{r prinComponents, echo=FALSE}
prinComponents <- function(exprs)
{
  #summary(prcomp(log10(exprs)))
  pca<-prcomp(exprs)$rotation
  x = pca[,1]; y = pca[,2]
  xadj<-0.1*(max(x)-min(x)); yadj<-0.1*(max(y)-min(y)) 
  plot(x,y,xlab="PC1", ylab="PC2", main="PC analysis on cohorts",
     xlim=c(min(x) - xadj, max(x) + xadj), ylim=c(min(y) - yadj, max(y) + yadj),
     pch=ifelse(meta$Cohort == 1, 1, 2),
     col=ifelse(meta$MicroarrayClass == "AC", "red", "blue")) 
  if (!HIDE) text(x,y+0.03,labels=rownames(pca), cex=0.7)
  legend("bottomright", c("Cohort1/AC", "Cohort2/AC", "Cohort1/PCC", "Cohort2/PCC"), 
      col=c("red","red","blue","blue"),
      pch=c(1,2,1,2))
}
```

```{r limma, echo=FALSE}
# Limma on the expression matrix and a level from meta
limmaOnData <- function(exprs, modFactor, fileName=NULL)
{
  mod<-model.matrix(~as.factor(eval(parse(text=modFactor))), data=meta) # The meta data should exist
  colnames(mod)[2]<-"outcome"
  eset.0 <- new("ExpressionSet", exprs=as.matrix(exprs))
  fit <- lmFit(eset.0, mod)
  fit2 <- eBayes(fit)
  res <- topTable(fit2, coef="outcome", number=nrow(exprs(eset.0)), adjust.method="BH", p.value=0.1)
  if (!is.null(fileName)) {
    write.table(merge(res, annot.f, by="row.names"), paste("results//", fileName, sep=""), sep="\t", row.names=F)
  }
  return(res)
}
```

Data preparation
--------------------

`annot.txt` is taken from `Single-experiment raw data3//annot3.txt`

`data.txt` are combined from `01.Data.Analysis.xlsx` and `11.Data.xlsx`.

`meta1.txt` is taken from `11 Annotations final cohorts sheet 2 20DEC13 DF.xlsx` and contains cohort information. The data has been transposed  to have patients names as columns for compatibility with `data.txt`

`meta2.txt` is taken from `20140214FarrisMicroarraymgdb(1).xlsx` (accessed on 03-13-2014). The data has been transposed. ID `p1033680-6` has been renamed to `p1033680-6 (-5)` to be compatible with the `data.txt` header.

```{r loadData, cache=TRUE, echo=FALSE}
# Full annotations. To avoid R errors on special characters, in Excel select "Description" column, use Ctrl+1, Custom category, \"@\" type
annot.f <- as.data.frame(read.table("data//annot_full.txt",sep="\t", quote="\"", header=T, as.is=T))
annot.f <- apply(annot.f, 2, function(x){sapply(x, function(y){gsub("\"", "", y)})}) # Remove \"
colnames(annot.f) <- c("ProbeName", "GeneName", "SystematicName", "Description") # Rename columns
rownames(annot.f) <- paste("gene", seq(1, nrow(annot.f)), sep="") # Dummy row names, to be later used for merging
# Expression data
exprs <- as.matrix(read.table("data//data.txt", sep="\t", header=T))
# Meta data
meta1 <- read.table("data//meta1.txt", sep="\t", header=T, row.names=1, as.is=T) # Has cohort
meta2 <- read.table("data//meta2.txt", sep="\t", header=T, row.names=1, as.is=T) # Has other clinical parameters
meta12 <- as.data.frame(rbind(meta1[1:2, intersect(colnames(meta1), colnames(meta2))], 
                              meta2[, intersect(colnames(meta1), colnames(meta2))])) # Need only the first two parameters from meta1. Join vertically by common names
patients <- colnames(meta12)[meta12["Microarray Class", ] == "AC" | meta12["Microarray Class", ] == "PSS"] # We use only two treatment conditions. Should be 34 patients. 
```

To identify the largest source of variability within the data, we perform principal component analysis and color the samples by Cohort/Treatment status.

```{r dataWithOutliers}
outliersRemove <- FALSE
meta <- loadMeta(outliersRemove)
exprs.n <- loadExprs(outliersRemove)
# arrayQualityMetrics(new("ExpressionSet", exprs=exprs.n), outdir="arrayQC_WithOutliers")
```

```{r PCAwithOutliers}
prinComponents(log2(exprs.n))
```

Clearly, the cohorts are very different. The two patients, p1033216.2 and p1033680.6...5., appear as outliers. They are also picked up by the _arrayQualityMetrics_ set of tests. 

We remove them and look at the principal components again.

```{r dataWithoutOutliers}
outliersRemove <- TRUE
meta <- loadMeta(outliersRemove)
exprs.n <- loadExprs(outliersRemove)
# arrayQualityMetrics(new("ExpressionSet", exprs=exprs.n), outdir="arrayQC_WithoutOutliers")
```

```{r PCAwithoutOutliers}
prinComponents(log2(exprs.n))
```

The data looks more homogeneous now, with the cohort effect still dominating.

To further investigate how the outliers affect differential gene expression, we will perform differential expression _limma_ analysis on the expression data with and without outlier, as well as check for the enriched pathways. 

```{r limmaWithOutliers}
<<dataWithOutliers>>
res <- limmaOnData(exprs.n, "MicroarrayClass")
nrow(res)
res.pathway <- reactomeEnrichment(res)
res.pathway[[2]]
```

Not many probes are differentially expressed out of `r nrow(exprs.n)` total. No pathway enrichment either.

```{r limmaWitouthOutliers}
<<dataWithoutOutliers>>
res <- limmaOnData(exprs.n, "MicroarrayClass")
nrow(res)
res.pathway <- reactomeEnrichment(res)
res.pathway[[2]]
```

Removing the outliers definitely helps to improve sensitivity in detecting differentially expressed genes. But not enough to see any pathway enrichment.

Using ComBat to account for batch effect
-----------------------------------------

To investigate batch effect in raw data, we will test the differences between the cohorts of patients, without considering their treatment status. The outliers were removed.

```{r limmaCohorts}
res <- limmaOnData(exprs.n, "Cohort")
nrow(res)
res.pathway <- reactomeEnrichment(res)
res.pathway[[2]]
```

Almost 1/3 of the probes are differentially expressed between cohorts. They show no pathway enrichment.

We use ComBat to manually adjust for the cohort effect and keep the treatment effect. If we look at the PCA plot after the adjustment, the data look more homogeneous, and the cohorts are now mixed together.

```{r combat}
combat_edata <- ComBat(dat=exprs.n, batch=meta$Cohort, mod=model.matrix(~as.factor(MicroarrayClass), data=meta), numCovs=NULL, par.prior=TRUE, prior.plots=F)
prinComponents(combat_edata)
```

And no differentially expressed genes can be detected after removing the batch effect.

```{r limmaOnCohortCombat}
res<-limmaOnData(combat_edata, "Cohort")
nrow(res)
```

Enrichment analysis
===================
Reactome canonical pathway enrichment analysis
----------------------------------------------

So far we used the complete dataset with 62976 probes. However, probes constantly expressed across the conditions are less interesting to us. To increase power of detecting differentially expressed genes, we filter such constantly expressed genes.

```{r dataFilter}
# Filtering low variability probes
combat_edata <- exprs(varFilter(new("ExpressionSet", exprs=combat_edata)))
nrow(combat_edata)
```

Almost half of the probes were removed. The number of DEGs expectedly increased (with less probes we have more power to detect DEGs) from 754 to 784.

After removing batch effect, we not only get more differentially expressed genes, but also enriched pathways. The total number, and the top 30 most tignificant pathways are shown.

```{r limmaOnTreatmentCombat}
res <- limmaOnData(combat_edata, "MicroarrayClass", "limma_MicroarrayClass_WithoutOutliers_WithoutBatch.txt")
nrow(res)
res.pathway <- reactomeEnrichment(res, "Cohort_Reactome.txt")
res.pathway[[2]]
grid.table(res.pathway[[1]][1:30, ], gp=gpar(fontsize=7))
```

And, enriched pathways from KEGG database

```{r limmaKEGG}
res.pathway <- Enrichment(res, "KEGG","Cohort_KEGG.txt")
res.pathway[[2]]
grid.table(res.pathway[[1]][1:10, ], gp=gpar(fontsize=7))
```

Let's have a look at top 50 differentially expressed genes. Multiple probes for the same gene are collapsed to one by maximum expression level.

```{r limmaVisual, warning=FALSE, fig.height=9}
degs <- collapseRows(combat_edata[rownames(res), ], annot.f[rownames(res), "GeneName"], rownames(res))
# Sort the collapsed data by the largest absolute fold change
maxRatio <- rowMeans(degs$datETcollapsed[, meta$MicroarrayClass == "PSS"])-
           rowMeans(degs$datETcollapsed[, meta$MicroarrayClass == "AC"])
degs.sorted <- degs$datETcollapsed[order(abs(maxRatio), decreasing=T), 
                                  order(meta$MicroarrayClass)]
# Or just use the most significant data, columns reordered
# degs.sorted <- degs$datETcollapsed[, order(meta$MicroarrayClass)]
color <- colorRampPalette(c("blue", "white", "red"))
if (HIDE) labCol="" else labCol=colnames(degs.sorted)
if (HIDE) labRow="" else labRow=rownames(degs.sorted)
heatmap.2(degs.sorted[1:50, ], Colv=F, Rowv=F, scale="row", trace="none", col=color, key=T, density.info="none", cexCol=1, cexRow=0.8, labCol=labCol, labRow=labRow[1:50])#, cellnote=formatC(1/10^abs(mtx), format="e", digits=2), notecol='darkgreen')
```

We aggregate probe names summarizing expression of the same gene by maximum fold change (because Ingenuity does it wrong).

```{r aggregateDegs}
# Merge limma results and annotations
tmp <- merge(res, annot.f, by="row.names")
# Get unique "gene name - max logFC" pairs"
degs <- aggregate(tmp[, "logFC"], by=list(tmp$GeneName), max)
degs.tmp <- merge(degs, tmp, by.x="x", by.y="logFC")
write.table(degs.tmp, "results/limma_MicroarrayClass_WithoutOutliers_WithoutBatch_IPA.txt", sep="\t", quote=F, col.names=NA)
```


Gene ontology enrichment analysis
-------------------------------------

First, look at the total number and the top 20 significant ontologies in the "Biological Process" space (Normally, most informative functions).

```{r GOBPEnrichment}
res.go <- Enrichment(res, "GO", "Cohort_GO_BP.txt", "BP")
res.go[[2]]
grid.table(res.go[[1]][1:20, ], gp=gpar(fontsize=6))
```

Second, look at the total number and the top 20 significant ontologies in the "Molecular Function" space (Second most informative).

```{r GOMFEnrichment}
res.go <- Enrichment(res, "GO", , "MF")
res.go[[2]]
grid.table(res.go[[1]][1:20, ], gp=gpar(fontsize=6))
```

Finally, look at the total number and the top 20 significant ontologies in the "Cellular Component" space (Least informative).

```{r GOCCEnrichment}
res.go <- Enrichment(res, "GO", , "CC")
res.go[[2]]
grid.table(res.go[[1]][1:20, ], gp=gpar(fontsize=6))
```


Genes best correlating with clinical parameters
=====================================
Interesting clinical parameters are: WUSFvol, SSFvolL, SSFvolR, LGleft, LGright, FS, LaBioRadvalue, RoBioRadvalue, RFvalue. For each clinical parameter, we answer 3 questions:

1) What are the top 20 genes best correlated with a clinical parameter?

2) Are those genes enriched in canonical pathways? Which? In how many?

3) Are those genes enriched in "biological process" gene ontologies? Which? In how many?

We can look at correlations in multiple ways:

1) Clinical parameter with all genes, e.g., clinCorrel(meta$WUSFvol, , combat_edata)

2) Clinical parameter with DEGs only, e.g., clinCorrel(meta$WUSFvol, , combat_edata[rownames(res), ])

3) Current. Clinical parameter with DEGs only in PSS group, e.g., 

Note, bug fixed: Now, GO and KEGG enrichment analyses are done using genes correlating with clinical parameters with p-value < 0.05.

WUSFvol
-----------
```{r WUSFvol_c1, fig.width=12}
correlGenes <- clinCorrel(meta$WUSFvol[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r WUSFvol_c2, fig.height=3, dependson="WUSFvol_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r WUSFvol_c3, dependson="WUSFvol_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```
SSFvolL
-----------
```{r SSFvolL_c1, fig.width=12}
correlGenes <- clinCorrel(meta$SSFvolL[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r SSFvolL_c2, fig.height=3, dependson="SSFvolL_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r SSFvolL_c3, dependson="SSFvolL_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

SSFvolR
-----------
```{r SSFvolR_c1, fig.width=12}
correlGenes <- clinCorrel(meta$SSFvolR[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r SSFvolR_c2, fig.height=3, dependson="SSFvolR_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r SSFvolR_c3, dependson="SSFvolR_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

LGleft
-----------
```{r LGleft_c1, fig.width=12}
correlGenes <- clinCorrel(meta$LGleft[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r LGleft_c2, fig.height=3, dependson="LGleft_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r LGleft_c3, dependson="LGleft_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

LGright
-----------
```{r LGright_c1, fig.width=12}
correlGenes <- clinCorrel(meta$LGright[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r LGright_c2, fig.height=3, dependson="LGright_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r LGright_c3, dependson="LGright_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

FS
-----------
```{r FS_c1, fig.width=12}
correlGenes <- clinCorrel(meta$FS[meta$MicroarrayClass == "PSS"], "clinCorrel.FS.genes", combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r FS_c2, dependson="FS_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ], "clinCorrel.FS.Pathways")
```

```{r FS_c3, dependson="FS_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ], "clinCorrel.FS.GO")
```

LaBioRadvalue
-----------
```{r LaBioRadvalue_c1, fig.width=12}
correlGenes <- clinCorrel(meta$LaBioRadvalue[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r LaBioRadvalue_c2, dependson="LaBioRadvalue_c1", fig.height=3}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r LaBioRadvalue_c3, dependson="LaBioRadvalue_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

RoBioRadvalue
-----------
```{r RoBioRadvalue_c1, fig.width=12}
correlGenes <- clinCorrel(meta$RoBioRadvalue[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r RoBioRadvalue_c2, dependson="RoBioRadvalue_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r RoBioRadvalue_c3, dependson="RoBioRadvalue_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

RFvalue
-----------
```{r RFvalue_c1, fig.width=12}
correlGenes <- clinCorrel(meta$RFvalue[meta$MicroarrayClass == "PSS"], , combat_edata[rownames(res), names(meta$FS[meta$MicroarrayClass == "PSS"])])
```

```{r RFvalue_c2, dependson="RFvalue_c1"}
clinCorrelPathways(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```

```{r RFvalue_c3, dependson="RFvalue_c1"}
clinCorrelGOs(correlGenes[correlGenes[, "Pval"] < 0.05, ])
```



TODO:

* Machine learning on clinical meta-data